# TODO. Move responsibilities
# Get rid of Game
# Clock tick onto Snake
# Set new position onto Apple
# Eating, and re-location to Apple
# Edge detection to Snake - Snake is initialised with board size.
# Top level playGame deals only with Snake, having passed it the field dimensions and initial Apple
main
    print welcome
    var k set to system.readKey()
    var newGame set to true
    while newGame
        call playGame()
        print "Do you want to play again (y/n)?"
        var answer set to ' '
        repeat
            set answer to system.readKey()
        until answer is 'y' or answer is 'n'
        if answer is 'n' then
            set newGame to false
        end if
    end while
end main

constant bodyColour set to Colour.green
constant appleColour set to Colour.red
constant directionByKey set to { 'w': Direction.up, 's' : Direction.down, 'a': Direction.left, 'd': Direction.right}
constant welcome set to "Welcome to the Snake game. 

Use the w,a,s, and d keys to control the direction of the snake. Letting the snake get to any edge will lose you the game, as will letting the snake's head pass over its body. Eating an apple will
cause the snake to grow by 

If you want to re-size the window, please do so now, before starting the game.

Click on this window to get 'focus' (and see a flashing cursor). Then press any key to start.."

procedure playGame()
    var charMap set to new CharMap()
    call charMap.fillBackground()
    var currentDirection set to Direction.right
    var game set to new Game((charMap.width/2).asInt(), charMap.height, currentDirection)
    var gameOn set to true
    call game.setNewApplePosition()
    while gameOn
        call draw(charMap, game.head(), bodyColour)
        call draw(charMap, game.apple, appleColour)
        var priorTail set to game.tail()
        call pause(200)
        var pressed set to system.keyHasBeenPressed()
        if pressed then
            var k set to system.readKey()
            set currentDirection to directionByKey[k]
        end if
        call game.clockTick(currentDirection, gameOn)
        if game.tail() is not priorTail then
            call draw(charMap, priorTail, charMap.backgroundColour)
        end if
    end while
#    call clearKeyBuffer()
    call charMap.setCursor(0, 0)
    print "Game Over! Score: {game.getScore()}"
end procedure

# maps from the Square coordinates & size, to characters
procedure draw(cm CharMap, sq Square, colour Colour)
    var col set to sq.x * 2
    var row set to sq.y
    call cm.putBlockWithColour(col, row, colour)
    call cm.putBlockWithColour(col + 1, row, colour) # because block is 2 chars wide
end procedure

class Game    
# Dimensions are number of Squares
    constructor (width Int, height Int, startingDirection Direction)
        set self.width to width
        set self.height to height
        set snake to new Snake(width div 2, height div 2, startingDirection) 
        call setNewApplePosition()
    end constructor

    private property width Int
    private property height Int
    private property snake Snake
    property apple Square

    function head() as Square
      return snake.head
    end function

    function tail() as Square
      return snake.tail()
    end function

    procedure clockTick(d Direction, out continue Bool)
        call snake.advanceHeadOneSquare(d)
        if snake.head is apple then
            call setNewApplePosition()
        else
            call snake.advanceTailOneSquare()
        end if
        set continue to not hasHitEdge() and not snake.hasHitItself()
    end procedure

    function hasHitEdge() as Bool
        var x set to snake.head.x
        var y set to snake.head.y
        return x < 0 or y < 0 or x is width or y is height
    end function

    procedure setNewApplePosition()
        var sq set to new Square(0,0)
        var collision set to false
        repeat
            var ranW set to system.random(width-1)
            var ranH set to system.random(height-1)
            set sq to new Square(ranW, ranH) 
        until not snake.bodyCovers(sq)
        set apple to sq
    end procedure

    function getScore() as Int
      return snake.length() - 2
    end function

    function asString() as String
      return "Game"
    end function
end class

class Snake
    constructor(x Int, y Int, startingDirection Direction)
        var tail set to new Square(x, y)
        set body to {tail}
        set head to tail.getAdjacentSquare(startingDirection)
    end constructor

    private property body List<of Square>
    property head Square

    function tail() as Square 
      return body[0]
    end function

    function hasHitItself() as Bool 
      return bodyCovers(head)
    end function

    function bodyCovers(sq Square) as Bool
      var result set to false
      foreach seg in body
        if (seg is sq) then
          set result to true
        end if
      end foreach
      return result
    end function

    procedure advanceHeadOneSquare(d Direction)
        set body to body + head
        set head to head.getAdjacentSquare(d)
    end procedure

    procedure advanceTailOneSquare()
        set body to body[1..]
    end procedure

    function length() as Int 
      return body.length()
    end function

    function asString() as String
      return "Snake"
    end function
end class

class Square
    constructor (x Int, y Int)
        set self.x to x
        set self.y to y
    end constructor

    property x Int
    property y Int

    function getAdjacentSquare(d Direction) as Square
        var newX set to x
        var newY set to y
        switch d
            case Direction.left
                set newX to newX - 1     
            case Direction.right
                set newX to newX + 1
            case Direction.up
                set newY to newY - 1 
            case Direction.down
                set newY to newY + 1
            default
        end switch
        return new Square(newX, newY)
    end function

    function asString() as String 
      return "{x},{y}"
    end function
end class